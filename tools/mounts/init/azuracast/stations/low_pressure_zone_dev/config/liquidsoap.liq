# WARNING! This file is automatically generated by AzuraCast.
# Do not update it directly!


# AzuraCast Common Runtime Functions
%include "/var/azuracast/liquidsoap/azuracast.liq"

log.level := 3
init.daemon.pidfile.path := "/var/azuracast/stations/low_pressure_zone_dev/config/liquidsoap.pid"

settings.init.compact_before_start := true

environment.set("TZ", "UTC") 

settings.azuracast.liquidsoap_api_port := 8004
settings.azuracast.api_url := "http://127.0.0.1:6010/api/internal/1/liquidsoap"
settings.azuracast.api_key := "01f44527810f628fc5d46c29236dd8aff4ccda01c0bf0982f960b3410860a9c546c8470a57951c1d36ad290912aa2a7d8673"
settings.azuracast.media_path := "/var/azuracast/stations/low_pressure_zone_dev/media"
settings.azuracast.fallback_path := "/usr/local/share/icecast/web/error.mp3"
settings.azuracast.temp_path := "/var/azuracast/stations/low_pressure_zone_dev/temp"

settings.azuracast.compute_autocue := false

settings.azuracast.default_fade := 2.00
settings.azuracast.default_cross := 3.00
settings.azuracast.enable_crossfade := true
settings.azuracast.crossfade_type := "normal"

settings.azuracast.live_broadcast_text := "Live Broadcast"

# Start HTTP API Server
azuracast.start_http_api()


playlist_archives = playlist(id="playlist_archives",mime_type="audio/x-mpegurl",mode="randomize",reload_mode="watch","/var/azuracast/stations/low_pressure_zone_dev/playlists/playlist_archives.m3u")

# Standard Playlists
radio = random(id="standard_playlists", weights=[3], [playlist_archives])

radio = azuracast.enable_autodj(radio)

requests = request.queue(id="requests", timeout=settings.azuracast.request_timeout())
radio = fallback(id="requests_fallback", track_sensitive = true, [requests, radio])

interrupting_queue = request.queue(id="interrupting_requests", timeout=settings.azuracast.request_timeout())
radio = fallback(id="interrupting_fallback", track_sensitive = false, [interrupting_queue, radio])

# Allow Telnet to skip the current track.
azuracast.utilities.add_skip_command(radio)

# Apply amplification metadata (if supplied)
# This can be disabled by setting:
#   settings.azuracast.apply_amplify := false
radio = azuracast.apply_amplify(radio)

# Log current metadata for debugging.
source.methods(radio).on_metadata(synchronous=false, azuracast.log_meta)

# Apply crossfade.
radio = azuracast.apply_crossfade(radio)

# A Pre-DJ source of radio that can be broadcast if needed
radio_without_live = radio
ignore(radio_without_live)

# Live Broadcasting
live = input.harbor("/live", id = "input_streamer", port = 8030, auth = azuracast.dj_auth, icy = true, icy_metadata_charset = "UTF-8", metadata_charset = "UTF-8", buffer = 5.00, max = 10.00)
live.on_connect(synchronous=false, azuracast.live_connected)
live.on_disconnect(synchronous=false, azuracast.live_disconnected)

def insert_missing(m) =
    def updates =
        if m == [] then
            [("title", "#{settings.azuracast.live_broadcast_text()}"), ("is_live", "true")]
        else
            [("is_live", "true")]
        end
    end
    updates
end

# Temporarily disabled for testing.
# live = metadata.map(insert_missing, live)

radio = fallback(
    id="live_fallback",
    track_sensitive=true,
    replay_metadata=true,
    transitions=[
        fun (_, s) -> begin
            log("executing transition to live")
            s
        end, 
        fun (_, s) -> begin
            s
        end
    ],
    [live, radio]
)

# Skip non-live track when live DJ goes live.
def check_live() =
    if live.is_ready() then
        if not azuracast.to_live() then
            azuracast.to_live := true
            radio_without_live.skip()
        end
    else
        azuracast.to_live := false
    end
end

# Continuously check on live.
source.methods(radio).on_frame(synchronous=true, check_live)

# Record Live Broadcasts
output.file(
    %ffmpeg(format="mp3", %audio(codec="libmp3lame", ac=2, ar=44100, b="320k")),
    fun () -> begin
        if (azuracast.live_enabled()) then
            time.string("#{settings.azuracast.temp_path()}/#{azuracast.live_dj()}/stream_%Y%m%d-%H%M%S.mp3.tmp")
        else
            ""
        end
    end,
    live,
    fallible=true,
    on_close=fun (tempPath) -> begin
        newPath = string.replace(pattern=".tmp$", (fun(_) -> ""), tempPath)

        log("Recording stopped: Switching from #{tempPath} to #{newPath}")

        process.run("mv #{tempPath} #{newPath}")
        ()
    end
)

# Allow for Telnet-driven insertion of custom metadata.
azuracast.utilities.add_custom_metadata_command(id="custom_metadata", radio)

# Add Fallback
radio = azuracast.add_fallback(radio)

# Send metadata changes back to AzuraCast
source.methods(radio).on_metadata(synchronous=false, azuracast.send_feedback)

# Handle "Jingle Mode" tracks by replaying the previous metadata.
radio = azuracast.handle_jingle_mode(radio)

# Local Broadcasts
output.icecast(%ffmpeg(format="mp3", %audio(codec="libmp3lame", ac=2, ar=44100, b="320k")), id="local_1", host = "127.0.0.1", port = 8000, password = "DExGYGJJ", mount = "/live-320", name = "Low Pressure Zone DEV", description = "", genre = "", public = false, encoding = "UTF-8", radio)

# Remote Relays